.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::RNA::SpliceSites::Scoring::MaxEntScan 3"
.TH Bio::RNA::SpliceSites::Scoring::MaxEntScan 3 "2014-08-18" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::RNA::SpliceSites::Scoring::MaxEntScan \- Perl module for pre\-mRNA splice site scoring by the maxEntScan algorithm of Gene Yeo and Chris Burge.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Bio::RNA::SpliceSites::Scoring::MaxEntScan qw/ score5 /;
.PP
my \f(CW$five_prime_splice_site\fR = q/ \s-1CAGGTTGGC\s0 /;
.PP
my \f(CW$five_prime_splice_site_score\fR = score5( \e$five_prime_splice_site ); #Return value is a scalar, not a reference.
.PP
use Bio::RNA::SpliceSites::Scoring::MaxEntScan qw/ score3 /;
.PP
my \f(CW$three_prime_splice_site\fR = q/ ctctactactatctatctagatc /; #Both scoring subroutines are case-insensitive.
.PP
my \f(CW$three_prime_splice_site_score\fR = score3( \e$three_prime_splice_site ); #Returns 6.71.
.PP
use Bio::MaxEntScan::SpliceSites::Scoring::MaxEntScan qw/ :all /; #Imports both subroutines.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module scores 5' and 3' splice sites using the maxEntScan algorithm.  See the original publication (citattion below) for details on the scoring algorithm.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.  The following two functions are available for export:
.PP
score5
score3
.PP
Both of these functions emulate the original maxEntScan scripts of the same names, except that they do not return a sequence string, only the score.  See below for descriptions.
.PP
The all tag:
.PP
:all
.PP
\&...imports both subroutines.
.PP
5' splice sites must be 9 nucleotides long  and must contain the 3' (terminal) 3 nucleotides of the exon and the first 6 nucleotides of the 5' end of the intron.
3' splice sites must be 23 nucleotides long and must contain the 3' (terminal) 20 nucleotides of the intron and the first 2 nucleotides of the 5' end of the exon.
.PP
Both functions will provide error messages on the standard error stream if a splice site of improper length is passed by reference.
.PP
Additional errors include an invalid genetic alphabet (must contain only [ACTGactg] nucleotides, no 'N' nucleotides are allowed by the algorithm) or passing a non-reference to the scoring subroutine(s).
.PP
The function will still return a value for errors to maintain output file structure.  These are:
.PP
\&'invalid_length'      An invalid splice site length is provided.
\&'invalid_alphabet'    Nucleotides other than [ACTGactg] were encountered, and the splice site cannot be scored.
\&'invalid_invocation'  A value that was not a scalar reference was passed to the scoring subroutine.
.SS "\s-1SUBROUTINES\s0 \s-1FOR\s0 \s-1SPLICE\s0 \s-1SITE\s0 \s-1SCORING\s0"
.IX Subsection "SUBROUTINES FOR SPLICE SITE SCORING"
.IP "score5" 1
.IX Item "score5"
When passed a reference to a scalar containing a nonamer sequence representing a 5' splice site to score, returns a scalar containing the score.
.Sp
5' splice sites must be 9 nucleotides long  and must contain the 3' (terminal) 3 nucleotides of the exon and the first 6 nucleotides of the 5' end of the intron.
.Sp
Both splice site scoring functions will provide error messages on the standard error stream if a splice site of improper length is passed by reference.
.Sp
Additional errors include an invalid genetic alphabet (must contain only [ACTGactg] nucleotides, no 'N' nucleotides are allowed by the algorithm) or passing a non-reference to the scoring subroutine(s).
.Sp
The function will still return a value for errors to maintain output file structure.  These are:
.Sp
\&'invalid_length'      An invalid splice site length is provided.
\&'invalid_alphabet'    Nucleotides other than [ACTGactg] were encountered, and the splice site cannot be scored.
\&'invalid_invocation'  A value that was not a scalar reference was passed to the scoring subroutine.
.IP "score3" 1
.IX Item "score3"
When passed a reference to a scalar containing a 23mer sequence representing a 3' splice site to score, returns a scalar containing the score.
.Sp
3' splice sites must be 23 nucleotides long and must contain the 3' (terminal) 20 nucleotides of the intron and the first 2 nucleotides of the 5' end of the exon.
.Sp
The same error messages generated by \fIscore5()\fR will be returned for an invalid subroutine invocation, and invalid 3'ss length, or an invalid genetic alphabet.
.SS "\s-1INTERNAL\s0 \s-1SUBROUTINES\s0"
.IX Subsection "INTERNAL SUBROUTINES"
The following subroutines are used internally by the above splice site scoring functions.
.IP "get_max_ent_score" 1
.IX Item "get_max_ent_score"
Returns the maxEntScore for the 3'ss.  This subroutine was developed from the \fIgetmaxentscore()\fR subroutine in the original score3.pl script provided with maxEntScan from \s-1MIT\s0.
.IP "get_splice_5_score_matrix_value" 1
.IX Item "get_splice_5_score_matrix_value"
Returns the score matrix value for a provided 5'ss.
.IP "get_splice_5_sequence_matrix_value" 1
.IX Item "get_splice_5_sequence_matrix_value"
Returns the sequence matrix value for a provided 5'ss.
.IP "hash_seq" 1
.IX Item "hash_seq"
Converts an oligonucleotide sequence (all uppercase) to a 4\-radix integer.  This approach was used in the original maxEntScan score3.pl program.
.IP "is_genetic_alphabet" 1
.IX Item "is_genetic_alphabet"
Returns 1 (\s-1TRUE\s0) if the sequence passed to the subroutine is in a valid genetic alphabet, 0 (\s-1FALSE\s0) otherwise.
.IP "is_kmer" 1
.IX Item "is_kmer"
When passed a sequence and an expected length, returns 1 (\s-1TRUE\s0) if the sequence is the expected length, and 0 (\s-1FALSE\s0) otherwise.
.IP "is_scalar_reference" 1
.IX Item "is_scalar_reference"
Checks the first argument to see if it is a reference, returning 1 (\s-1TRUE\s0) if yes, otherwise 0 (\s-1FALSE\s0).
.IP "log2" 1
.IX Item "log2"
Converts its argument into a log2.  See the documentation for the `log` function.
.IP "score_consensus" 1
.IX Item "score_consensus"
When passed a splice site consensus dinucleotide and the splice site type as an integer (either 5 or 3), scores the splice donor or splice acceptor dinucleotide according to background values specific for the specified splice site type.  This subroutine is used by both \fIscore5()\fR and \fIscore3()\fR subroutines.
.IP "split_sequence" 1
.IX Item "split_sequence"
When passed a scalar splice site sequence and the splice site type as an integer (either 5 or 3), splits the splice site into the splice donor/acceptor dinucleotide and the concatenated remainder of the scalar.  This subroutine is used by both the \fIscore5()\fR and \fIscore3()\fR subroutines.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Algorithm:
.PP
J Comput biol. 2004;11(2\-3):377\-94
Maximum entropy modeling of short sequence motifs with applications to \s-1RNA\s0 splicing signals.
Yeo G, Burge \s-1CB\s0
\&\s-1PMID:\s0 15285897
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Sebastian Cole, <colebr@mail.med.upenn.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
maxEntScan algorithm:
Copyright (C) 2004 by Gene Yeo and Chris Burge
.PP
This distrubtion:
Copyright (C) 2014 by Brian Sebastian Cole
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.14.2 or,
at your option, any later version of Perl 5 you may have available.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
The author would like to acknowledge the support of his thesis advisor Dr. Kristen Lynch, PhD.
.PP
Thanks go to John Karr of the Philadelphia Perl Mongers for the sagacious suggestion of using data submodules to hold splice models.
